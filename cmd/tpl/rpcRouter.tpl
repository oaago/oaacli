// Code generated by oaago DO NOT EDIT.
// Code generated by oaago DO NOT EDIT.
// Code generated by oaago DO NOT EDIT.
package router
import (
	"context"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"github.com/oaago/cloud/op"
	"google.golang.org/grpc"
	"github.com/oaago/server/oaa"
	grpcmiddleware "github.com/grpc-ecosystem/go-grpc-middleware"
	grpcauth "github.com/grpc-ecosystem/go-grpc-middleware/auth"
	grpczap "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	"github.com/grpc-ecosystem/go-grpc-middleware/ratelimit"
	grpcrecovery "github.com/grpc-ecosystem/go-grpc-middleware/recovery"
	grpcctxtags "github.com/grpc-ecosystem/go-grpc-middleware/tags"
	grpcopentracing "github.com/grpc-ecosystem/go-grpc-middleware/tracing/opentracing"
	grpc_validator "github.com/grpc-ecosystem/go-grpc-middleware/validator"
	grpcprometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
	"google.golang.org/grpc/codes"
	"github.com/oaago/cloud/logx"
	"google.golang.org/protobuf/encoding/protojson"
	"strconv"
{{range $index, $item := .MapHandlerMap}}
	{{$item.UpPackage}}{{$item.UpMethod}} "{{$item.Module}}/internal/api/rpc/{{$item.Package}}/{{$item.Method}}"
	SRV{{$item.UpPackage}}{{$item.UpMethod}} "{{$item.Module}}/internal/service/rpc/{{$item.Package}}/{{$item.Method}}"
{{end}}
)

type alwaysPassLimiter struct{}
type Recovery struct {
}

func (*alwaysPassLimiter) Limit() bool {
	return false
}

func (re Recovery) RecoveryInterceptor() grpcrecovery.Option {
	return grpcrecovery.WithRecoveryHandler(func(p interface{}) (err error) {
		return grpc.Errorf(codes.Unknown, "panic triggered: %v", p)
	})
}

func (c ConfigRouter)RegisterRpcGenRouter() *grpc.Server {
	limiter := &alwaysPassLimiter{}
	recovery := &Recovery{}
	s := grpc.NewServer(
		grpc.StreamInterceptor(grpcmiddleware.ChainStreamServer(
			grpczap.StreamServerInterceptor(logx.Logx),
			grpcctxtags.StreamServerInterceptor(),
			grpcopentracing.StreamServerInterceptor(),
			grpcprometheus.StreamServerInterceptor,
			grpcauth.StreamServerInterceptor(func(ctx context.Context) (context.Context, error) {
				return nil, nil
			}),
			ratelimit.StreamServerInterceptor(limiter),
			grpc_validator.StreamServerInterceptor(),
			grpcrecovery.StreamServerInterceptor(recovery.RecoveryInterceptor()),
		)),
		grpc.UnaryInterceptor(grpcmiddleware.ChainUnaryServer(
			grpczap.UnaryServerInterceptor(logx.Logx),
			grpcctxtags.UnaryServerInterceptor(),
			grpcopentracing.UnaryServerInterceptor(),
			grpcprometheus.UnaryServerInterceptor,
			ratelimit.UnaryServerInterceptor(limiter),
			grpcauth.UnaryServerInterceptor(func(ctx context.Context) (context.Context, error) {
					return nil, nil
			}),
			grpc_validator.UnaryServerInterceptor(),
			grpcrecovery.UnaryServerInterceptor(recovery.RecoveryInterceptor()),
		)),
	)
	ctx := context.Background()
	mux := runtime.NewServeMux(runtime.WithMarshalerOption(runtime.MIMEWildcard, &runtime.JSONPb{MarshalOptions: protojson.MarshalOptions{UseEnumNumbers: true, UseProtoNames: true}}))
	var err error {{range $index, $item := .MapHandlerMap}}
	err = {{$item.UpPackage}}{{$item.UpMethod}}.Register{{$item.UpPackage}}{{$item.UpMethod}}GWFromEndpoint(ctx, mux, "localhost:" + strconv.Itoa(op.ConfigData.Server.Port+1000), []grpc.DialOption{grpc.WithInsecure()})
	if err != nil {
		panic(err)
	}
	{{$item.UpPackage}}{{$item.UpMethod}}.Register{{$item.UpPackage}}{{$item.UpMethod}}Server(s, SRV{{$item.UpPackage}}{{$item.UpMethod}}.NewService{{$item.UpPackage}}{{$item.UpMethod}}())
	{{$item.UpPackage}}{{$item.UpMethod}}.Register{{$item.UpPackage}}{{$item.UpMethod}}HTTPServer(c.Engine, SRV{{$item.UpPackage}}{{$item.UpMethod}}.NewService{{$item.UpPackage}}{{$item.UpMethod}}())
	{{end}}
	return s
}